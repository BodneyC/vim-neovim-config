# A valid snippet should starts with:
#
#		snippet trigger_word [ "description" [ options ] ]
#
# and end with:
#
#		endsnippet
#
# Snippet options:
#
#		b - Beginning of line.
#		i - In-word expansion.
#		w - Word boundary.
#		r - Regular expression
#		e - Custom context snippet
#		A - Snippet will be triggered automatically, when condition matches.
#
# Basic example:
#
#		snippet emitter "emitter properties" b
#		private readonly ${1} = new Emitter<$2>()
#		public readonly ${1/^_(.*)/$1/}: Event<$2> = this.$1.event
#		endsnippet
#
# Online reference: https://github.com/SirVer/ultisnips/blob/master/doc/UltiSnips.txt

snippet _msg_exit "_msg_exit function" b
_msg_exit() { # msg[, ret_val]
	echo "\$1, exiting..."
	[[ -n "\$2" ]] && exit "\$2"
}
endsnippet

snippet _yes_or_no "_yes_or_no function" b
_yes_or_no() { # msg
	# shellcheck disable=SC2050
	while true; do
		read -rp "\$1 [yn] "
		case "$REPLY" in
			[yY]*) return 0 ;;
			[nN]*) return 1 ;;
			*)     echo "Invalid option"
		esac
	done
}
endsnippet

snippet _argparse "BaSH argument parser" b
_argparse() {
	_argparse_done_check() {
		[[ -z "\$1" && -z "\$2" ]] && echo 1
	}

	argv=()
	cmd=""
	arg_end=""

	[[ \$# == 0 ]] && cmd="help"

	shopt -s extglob

	while [[ -n "\$1" ]]; do
		CHECK=\$(_argparse_done_check "\$cmd" "\$arg_end")
		case "\$1" in
			--) arg_end=1 ;;
			-*) case "\$1" in
					-h)           [[ -n "\$CHECK" ]] && cmd="help"    || argv+=("\$1") ;;
					-H|--help)    [[ -n "\$CHECK" ]] && cmd="HELP"    || argv+=("\$1") ;;
					-v)           [[ -n "\$CHECK" ]] && cmd="version" || argv+=("\$1") ;;
					-V|--version) [[ -n "\$CHECK" ]] && cmd="VERSION" || argv+=("\$1") ;;
					*)            [[ -n "\$CHECK" ]] \
									&& _exit_msg "Unknown option: \$1" "\$EOPTN" \
									|| argv+=("\$1")
				esac ;;
			command1) [[ -n "\$CHECK" ]] && cmd="command1" || argv+=("\$1") ;;
			command2) [[ -n "\$CHECK" ]] && cmd="command2" || argv+=("\$1") ;;
			command3) [[ -n "\$CHECK" ]] && cmd="command3" || argv+=("\$1") ;;
			command4) [[ -n "\$CHECK" ]] && cmd="command4" || argv+=("\$1") ;;
			*)        [[ -n "\$CHECK" ]] && cmd="\$1"   || argv+=("\$1") ;;
		esac
		shift
	done

	if ! type "func_\$cmd" >& /dev/null; then
		_exit_msg "Unknown command: func_\$cmd" "\$EOPTN"
	fi

	"func_\$cmd" "\${argv[@]}"
}
endsnippet

snippet _simple_argparse "Simple BaSH argument parser" b
_argparse() {
	shopt -s extglob

	while [[ -n "\$1" ]]; do
		case "\$1" in
			--) arg_end=1 ;;
			-*) case "\$1" in
					-h)              func_help ;;
					-n|--name)       REPO_NAME="\$2"; shift ;;
					-v|--visibility) REPO_VISI="\$2"; shift ;;
					-g|--group)      REPO_GROU="\$2"; shift ;;
					*)               _exit_msg "Unknown option: \$1" "\$EOPTN"
				esac ;;
			*) _exit_msg "Unknown option: \$1" "\$EOPTN"
		esac
		shift
	done
}
endsnippet

snippet shellcheck "Shellcheck disable" i
# shellcheck disable=
endsnippet

snippet bash "env shebang" b
#!/usr/bin/env bash
endsnippet
